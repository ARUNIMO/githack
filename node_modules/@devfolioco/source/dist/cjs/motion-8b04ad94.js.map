{"version":3,"file":"motion-8b04ad94.js","sources":["../../node_modules/framer-motion/dist/es/events/use-dom-event.js","../../node_modules/framer-motion/dist/es/gestures/utils/event-type.js","../../node_modules/framer-motion/dist/es/events/event-info.js","../../node_modules/framer-motion/dist/es/events/utils.js","../../node_modules/framer-motion/dist/es/events/use-pointer-event.js","../../node_modules/framer-motion/dist/es/gestures/PanSession.js","../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.js","../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.js","../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.js","../../node_modules/framer-motion/dist/es/motion/features/drag.js","../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.js","../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.js","../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.js","../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.js","../../node_modules/framer-motion/dist/es/gestures/use-gestures.js","../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.js","../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.js","../../node_modules/framer-motion/dist/es/motion/features/gestures.js","../../node_modules/framer-motion/dist/es/motion/features/layout/Animate.js","../../node_modules/framer-motion/dist/es/motion/features/layout/utils.js","../../node_modules/framer-motion/dist/es/render/dom/motion.js"],"sourcesContent":["import { useEffect } from 'react';\n\nfunction addDomEvent(target, eventName, handler, options) {\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\nexport { addDomEvent, useDomEvent };\n","function isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\nexport { isMouseEvent, isTouchEvent };\n","import { isTouchEvent } from '../gestures/utils/event-type.js';\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\nexport { extractEventInfo, getViewportPointFromEvent, wrapHandler };\n","var isBrowser = typeof window !== \"undefined\";\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nexport { supportsMouseEvents, supportsPointerEvents, supportsTouchEvents };\n","import { wrapHandler } from './event-info.js';\nimport { useDomEvent, addDomEvent } from './use-dom-event.js';\nimport { supportsPointerEvents, supportsTouchEvents, supportsMouseEvents } from './utils.js';\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nexport { addPointerEvent, usePointerEvent };\n","import { __assign } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { distance, pipe } from 'popmotion';\nimport { secondsToMilliseconds } from '../utils/time-conversion.js';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.js';\nimport { extractEventInfo } from '../events/event-info.js';\nimport { addPointerEvent } from '../events/use-pointer-event.js';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var onEnd = _this.handlers.onEnd;\n            if (!onEnd || !_this.startEvent)\n                return;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            onEnd && onEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n","function createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nexport { createLock, getGlobalLock, isDragActive };\n","import { __read } from 'tslib';\nimport { mix } from 'popmotion';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = __read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\nexport { applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n","import { __rest, __assign } from 'tslib';\nimport { progress } from 'popmotion';\nimport { eachAxis } from '../../utils/each-axis.js';\nimport { axisBox, convertAxisBoxToBoundingBox, convertBoundingBoxToAxisBox } from '../../utils/geometry/index.js';\nimport { calcOrigin } from '../../utils/geometry/delta-calc.js';\nimport { isRefObject } from '../../utils/is-ref-object.js';\nimport { invariant } from 'hey-listen';\nimport { startAnimation } from '../../animation/utils/transitions.js';\nimport { AnimationType } from '../../render/utils/types.js';\nimport { getBoundingBox } from '../../render/dom/projection/measure.js';\nimport { getViewportPointFromEvent } from '../../events/event-info.js';\nimport { addDomEvent } from '../../events/use-dom-event.js';\nimport { addPointerEvent } from '../../events/use-pointer-event.js';\nimport { PanSession } from '../PanSession.js';\nimport { getGlobalLock } from './utils/lock.js';\nimport { calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, defaultElastic } from './utils/constraints.js';\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        /**\n         * If this drag session has been manually triggered by the user, it might be from an event\n         * outside the draggable element. If snapToCursor is set to true, we need to measure the position\n         * of the element and snap it to the cursor.\n         */\n        snapToCursor && this.snapToCursor(originEvent);\n        var onSessionStart = function () {\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            /**\n             * Record the progress of the mouse within the draggable element on each axis.\n             * onPan, we're going to use this to calculate a new bounding box for the element to\n             * project into. This will ensure that even if the DOM element moves via a relayout, it'll\n             * stick to the correct place under the pointer.\n             */\n            _this.prepareBoundingBox();\n            _this.visualElement.lockProjectionTarget();\n            /**\n             * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\n             * relative to the element's layout, or a ref to another element. Both need converting to\n             * viewport coordinates.\n             */\n            _this.resolveDragConstraints();\n            /**\n             * When dragging starts, we want to find where the cursor is relative to the bounding box\n             * of the element. Every frame, we calculate a new bounding box using this relative position\n             * and let the visualElement renderer figure out how to reproject the element into this bounding\n             * box.\n             *\n             * By doing it this way, rather than applying an x/y transform directly to the element,\n             * we can ensure the component always visually sticks to the cursor as we'd expect, even\n             * if the DOM element itself changes layout as a result of React updates the user might\n             * make based on the drag position.\n             */\n            var point = getViewportPointFromEvent(event).point;\n            eachAxis(function (axis) {\n                var _a = _this.visualElement.projection.target[axis], min = _a.min, max = _a.max;\n                _this.cursorProgress[axis] = cursorProgress\n                    ? cursorProgress[axis]\n                    : progress(min, max, point[axis]);\n                /**\n                 * If we have external drag MotionValues, record their origin point. On pointermove\n                 * we'll apply the pan gesture offset directly to this value.\n                 */\n                var axisValue = _this.getAxisMotionValue(axis);\n                if (axisValue) {\n                    _this.originPoint[axis] = axisValue.get();\n                }\n            });\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", event, offset);\n            _this.updateAxis(\"y\", event, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onEnd = function (event, info) { return _this.stop(event, info); };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onEnd: onEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    /**\n     * Ensure the component's layout and target bounding boxes are up-to-date.\n     */\n    VisualElementDragControls.prototype.prepareBoundingBox = function () {\n        var visualElement = this.visualElement;\n        visualElement.withoutTransform(function () {\n            visualElement.updateLayoutMeasurement();\n        });\n        visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(this.visualElement.getLayoutState().layout, dragConstraints)\n                : calcRelativeConstraints(this.visualElement.getLayoutState().layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(_this.visualElement.getLayoutState().layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a;\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var _b = this.props, dragMomentum = _b.dragMomentum, onDragEnd = _b.onDragEnd;\n        if (dragMomentum || this.elastic) {\n            var velocity = info.velocity;\n            this.animateDragEnd(velocity);\n        }\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (event) {\n        var _this = this;\n        this.prepareBoundingBox();\n        eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var point = getViewportPointFromEvent(event).point;\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                _this.updateVisualElementAxis(axis, event);\n            }\n        });\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, event, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, event);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, event) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        var point = getViewportPointFromEvent(event).point;\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = __assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        var momentumAnimations = eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = _this.constraints ? _this.constraints[axis] : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.prepareBoundingBox();\n        this.resolveDragConstraints();\n        eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            // Calculate the position of the targetBox relative to the constraintsBox using the\n            // previously calculated progress\n            var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n            _this.visualElement.setProjectionTargetAxis(axis, min, max);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging)\n                _this.resolveDragConstraints();\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n","import { __rest } from 'tslib';\nimport { useDrag } from '../../gestures/drag/use-drag.js';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\n\nvar Component = makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\n    return useDrag(props, visualElement);\n});\n/**\n * @public\n */\nvar Drag = {\n    key: \"drag\",\n    shouldRender: function (props) { return !!props.drag || !!props.dragControls; },\n    getComponent: function () { return Component; },\n};\n\nexport { Drag };\n","import { __assign } from 'tslib';\nimport { useContext, useEffect } from 'react';\nimport { useConstant } from '../../utils/use-constant.js';\nimport { MotionConfigContext } from '../../motion/context/MotionConfigContext.js';\nimport { VisualElementDragControls } from './VisualElementDragControls.js';\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props, visualElement) {\n    var groupDragControls = props.dragControls;\n    var transformPagePoint = useContext(MotionConfigContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.setProps(__assign(__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\nexport { useDrag };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","import { pipe } from 'popmotion';\nimport { AnimationType } from '../render/utils/types.js';\nimport { useRef } from 'react';\nimport { usePointerEvent, addPointerEvent } from '../events/use-pointer-event.js';\nimport { isDragActive } from './drag/utils/lock.js';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.js';\nimport { isNodeOrChild } from './utils/is-node-or-child.js';\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a, visualElement) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = useRef(false);\n    var cancelPointerEndListeners = useRef(null);\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };\n","import { AnimationType } from '../render/utils/types.js';\nimport { isMouseEvent } from './utils/event-type.js';\nimport { usePointerEvent } from '../events/use-pointer-event.js';\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || !visualElement.isHoverEventsEnabled)\n            return;\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n    };\n}\nfunction useHoverGesture(_a, visualElement) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined);\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined);\n}\n\nexport { useHoverGesture };\n","import { usePanGesture } from './use-pan-gesture.js';\nimport { useTapGesture } from './use-tap-gesture.js';\nimport { useHoverGesture } from './use-hover-gesture.js';\nimport { useFocusGesture } from './use-focus-gesture.js';\n\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\nfunction useGestures(props, visualElement) {\n    usePanGesture(props, visualElement);\n    useTapGesture(props, visualElement);\n    useHoverGesture(props, visualElement);\n    useFocusGesture(props, visualElement);\n}\n\nexport { useGestures };\n","import { useRef, useContext, useEffect } from 'react';\nimport { MotionConfigContext } from '../motion/context/MotionConfigContext.js';\nimport { usePointerEvent } from '../events/use-pointer-event.js';\nimport { PanSession } from './PanSession.js';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.js';\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a, ref) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = useRef(null);\n    var transformPagePoint = useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\nexport { usePanGesture };\n","import { AnimationType } from '../render/utils/types.js';\nimport { useDomEvent } from '../events/use-dom-event.js';\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a, visualElement) {\n    var whileFocus = _a.whileFocus;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nexport { useFocusGesture };\n","import { __rest } from 'tslib';\nimport { gestureProps } from '../../gestures/types.js';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\nimport { useGestures } from '../../gestures/use-gestures.js';\n\nvar GestureComponent = makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\n    useGestures(props, visualElement);\n});\n/**\n * @public\n */\nvar Gestures = {\n    key: \"gestures\",\n    shouldRender: function (props) {\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\n    },\n    getComponent: function () { return GestureComponent; },\n};\n\nexport { Gestures };\n","import { __extends, __rest, __read, __assign } from 'tslib';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation } from '../../../animation/utils/transitions.js';\nimport { Component, createElement } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { tweenAxis } from './utils.js';\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    __extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.frameTarget = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], config);\n                }\n                else {\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _b, _c;\n        var transition = (_a === void 0 ? {} : _a).transition;\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Ensure that the layout delta is updated for this frame.\n        visualElement.updateLayoutProjection();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(unsubscribeProgress);\n        this.stopAxisAnimation[axis] = function () {\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = __read(usePresence(), 2), safeToRemove = _a[1];\n    return createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\n/**\n * @public\n */\nvar AnimateLayout = {\n    key: \"animate-layout\",\n    shouldRender: function (props) {\n        return !!props.layout || props.layoutId !== undefined;\n    },\n    getComponent: function () { return AnimateLayoutContextProvider; },\n};\n\nexport { AnimateLayout };\n","import { mix } from 'popmotion';\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = mix(prev.min, next.min, p);\n    target.max = mix(prev.max, next.max, p);\n}\n\nexport { tweenAxis };\n","import { createDomVisualElement } from './create-dom-visual-element.js';\nimport { createUseRender } from './use-render.js';\nimport { createMotionComponent } from '../../motion/index.js';\nimport { Drag } from '../../motion/features/drag.js';\nimport { Gestures } from '../../motion/features/gestures.js';\nimport { Exit } from '../../motion/features/exit.js';\nimport { Animation } from '../../motion/features/animation.js';\nimport { AnimateLayout } from '../../motion/features/layout/Animate.js';\nimport { MeasureLayout } from '../../motion/features/layout/Measure.js';\nimport { createMotionProxy } from './motion-proxy.js';\n\nvar allMotionFeatures = [\n    MeasureLayout,\n    Animation,\n    Drag,\n    Gestures,\n    Exit,\n    AnimateLayout,\n];\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(allMotionFeatures);\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    var config = {\n        createVisualElement: createDomVisualElement(key),\n        useRender: createUseRender(key, false),\n        defaultFeatures: allMotionFeatures,\n    };\n    return createMotionComponent(config);\n}\n\nexport { createDomMotionComponent, motion };\n"],"names":["addDomEvent","target","eventName","handler","options","addEventListener","removeEventListener","useDomEvent","ref","useEffect","element","current","isMouseEvent","event","PointerEvent","pointerType","MouseEvent","isTouchEvent","touches","defaultPagePoint","pageX","pageY","pointFromTouch","e","pointType","point","changedTouches","x","y","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","eventHandler","listener","button","isBrowser","window","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","name","onpointerdown","ontouchstart","onmousedown","addPointerEvent","usePointerEvent","PanSession","handlers","_a","_this","this","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","distance","offset","timestamp","getFrameData","push","__assign","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","sync","update","end","onEnd","panInfo","length","initialInfo","onSessionStart","removeListeners","pipe","prototype","updateHandlers","cancelSync","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","currentVelocity","Infinity","createLock","lock","globalHorizontalLock","globalVerticalLock","getGlobalLock","drag","openHorizontal_1","openVertical_1","applyConstraints","elastic","min","max","undefined","mix","Math","calcRelativeAxisConstraints","axis","calcViewportAxisConstraints","layoutAxis","constraintsAxis","__read","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","lastPointerEvent","elementDragControls","WeakMap","VisualElementDragControls","visualElement","isDragging","currentDirection","constraints","axisBox","props","hasMutatedConstraints","cursorProgress","originPoint","openGlobalLock","panSession","enableLayoutProjection","set","start","originEvent","_b","_c","snapToCursor","stopMotion","_d","dragPropagation","prepareBoundingBox","lockProjectionTarget","resolveDragConstraints","eachAxis","projection","progress","axisValue","getAxisMotionValue","get","onDragStart","call","animationState","setActive","AnimationType","Drag","_e","dragDirectionLock","lockThreshold","direction","abs","getCurrentDirection","onDirectionLock","updateAxis","onDrag","stop","withoutTransform","updateLayoutMeasurement","rebaseProjectionTarget","measureViewportBox","dragConstraints","isRefObject","resolveRefConstraints","getLayoutState","layout","layoutBox","top","left","bottom","right","calcRelativeConstraints","resolveDragElastic","relativeConstraints","onMeasureDragConstraints","constraintsElement","invariant","constraintsBox","getBoundingBox","measuredConstraints","calcViewportConstraints","userConstraints","convertAxisBoxToBoundingBox","convertBoundingBoxToAxisBox","cancelDrag","unlockProjectionTarget","dragMomentum","onDragEnd","animateDragEnd","shouldDrag","box","length_1","center","updateVisualElementAxis","updateAxisMotionValue","nextValue","axisLayout","axisLength","axisProgress","calcConstrainedMinPoint","setProjectionTargetAxis","setProps","_f","_g","remainingProps","__rest","layoutId","dragKey","toUpperCase","getValue","dragTransition","momentumAnimations","transition","bounceStiffness","bounceDamping","inertia","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","startLayoutAnimation","Promise","all","then","onDragTransitionEnd","stopLayoutAnimation","currentValue","startAnimation","scalePoint","boxProgress","calcOrigin","calcPositionFromProgress","mount","stopPointerListener","getInstance","dragListener","stopResizeListener","stopLayoutUpdateListener","onLayoutUpdate","prevDragCursor","Component","makeRenderlessComponent","groupDragControls","dragControls","useContext","MotionConfigContext","useConstant","subscribe","useDrag","key","shouldRender","getComponent","isNodeOrChild","parent","child","parentElement","useTapGesture","onTap","onTapStart","onTapCancel","whileTap","hasPressListeners","isPressing","useRef","cancelPointerEndListeners","removePointerEndListener","checkPointerEnd","openGestureLock","Tap","onPointerUp","onPointerCancel","useUnmountEffect","createHoverEvent","isActive","callback","isHoverEventsEnabled","Hover","useGestures","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","onHoverStart","onHoverEnd","whileHover","useHoverGesture","whileFocus","Focus","useFocusGesture","GestureComponent","Gestures","gestureProps","some","hasOwnProperty","Animate","_super","apply","arguments","frameTarget","stopAxisAnimation","isAnimatingTree","animate","origin","originBox","targetBox","visibilityAction","shouldStackAnimate","onComplete","config","safeToRemove","boxHasMoved","hasMoved","animations","targetLength","isTargetLocked","animateAxis","setVisibility","VisibilityAction","Show","syncRender","notifyLayoutAnimationComplete","__extends","componentDidMount","animateMotionValue","unsubLayoutReady","layoutSafeToRemove","componentWillUnmount","layoutProgress","getProjectionAnimationProgress","clearListeners","frame","p","prev","next","tweenAxis","updateLayoutProjection","unsubscribeProgress","onChange","animation","defaultTransition","render","AnimateLayoutContextProvider","usePresence","createElement","isZeroBox","axisIsEqual","zeroAxis","duration","ease","AnimateLayout","allMotionFeatures","MeasureLayout","Animation","Exit","motion","createMotionProxy"],"mappings":"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"}